#define SDL_MAIN_USE_CALLBACKS 1
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>
#include <stdlib.h>
#include <cmath>
#include <iostream>
#include <algorithm>

#define WINDOW_WIDTH 1000
#define WINDOW_HEIGHT 1000

int halfWidth = WINDOW_WIDTH/2;
int halfHeight = WINDOW_HEIGHT/2;

static SDL_Window* window = NULL;
static SDL_Renderer* renderer = NULL;
static SDL_Texture* texture = NULL;

constexpr int amountOfPixels = WINDOW_WIDTH*WINDOW_HEIGHT;

Uint32 pixelBuffer[amountOfPixels];

constexpr int largestSize =  WINDOW_HEIGHT; //WINDOW_WIDTH > WINDOW_HEIGHT ? WINDOW_WIDTH : WINDOW_HEIGHT;

int triangleBuffer[2 * largestSize];

double a;

static void placePoint(int x, int y) {
    int p = x + WINDOW_WIDTH * y;
    //Uint8 firstByte = (colour >> 24) & 0xFF;
    pixelBuffer[p] = 0xFFFFFFFF;
}

static void minMaxPlot(int x0,int y0){
    if (x0 >= 0 && x0 < WINDOW_WIDTH && y0 >= 0 && y0 < WINDOW_HEIGHT)
    {
        int yMax = y0 + largestSize;
        if (triangleBuffer[y0] == -1) {
            triangleBuffer[y0] = x0;
            triangleBuffer[yMax] = x0;
        } else {
            if (x0 < triangleBuffer[y0])
                triangleBuffer[y0] = x0;
            if (x0 > triangleBuffer[yMax])
                triangleBuffer[yMax] = x0;
        }
    }
}

static void DrawLine(int x0, int y0, int x1, int y1)
{
    bool steep = abs(y1 - y0) > abs(x1 - x0);

    if (steep) {
        std::swap(x0, y0);
        std::swap(x1, y1);
    }

    if (x0 > x1) {
        std::swap(x0, x1);
        std::swap(y0, y1);
    }

    int dx = x1 - x0;
    int dy = abs(y1 - y0);
    int p = dx / 2;
    int ystep = (y0 < y1) ? 1 : -1;
    int y = y0;

    for (int x = x0; x <= x1; ++x) {
        if (steep)
            minMaxPlot(y, x);
        else
            minMaxPlot(x, y);

        p -= dy;
        if (p < 0) {
            y += ystep;
            p += dx;
        }
    }
}

static void triangle(float x1, float y1, float x2, float y2, float x3, float y3) {

    SDL_memset(triangleBuffer, -1, sizeof(int)*largestSize*2);
    
    int ix1 = static_cast<int>(x1) + halfWidth;
    int iy1 = static_cast<int>(y1) + halfHeight;
    int ix2 = static_cast<int>(x2) + halfWidth;
    int iy2 = static_cast<int>(y2) + halfHeight;
    int ix3 = static_cast<int>(x3) + halfWidth;
    int iy3 = static_cast<int>(y3) + halfHeight;

    DrawLine(ix1,iy1,ix2,iy2);
    DrawLine(ix2, iy2, ix3, iy3);
    DrawLine(ix3, iy3, ix1, iy1);

    for (int y = 0; y < largestSize; y++)
    {
        if(triangleBuffer[y] != -1){
            for (int x = 0; x < (triangleBuffer[y + largestSize] - triangleBuffer[y]); x++)
            {
                placePoint(x+triangleBuffer[y],y);
            }
        }
    } 
}

SDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[])
{
    SDL_SetAppMetadata("Example Renderer Streaming Textures", "1.0", "com.example.renderer-streaming-textures");

    if (!SDL_Init(SDL_INIT_VIDEO)) {
        SDL_Log("Couldn't initialize SDL: %s", SDL_GetError());
        return SDL_APP_FAILURE;
    }

    if (!SDL_CreateWindowAndRenderer("FastEngine", WINDOW_WIDTH, WINDOW_HEIGHT, 0, &window, &renderer)) {
        SDL_Log("Couldn't create window/renderer: %s", SDL_GetError());
        return SDL_APP_FAILURE;
    }

    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING, WINDOW_WIDTH, WINDOW_HEIGHT);
    if (!texture) {
        SDL_Log("Couldn't create streaming texture: %s", SDL_GetError());
        return SDL_APP_FAILURE;
    }

    return SDL_APP_CONTINUE;
}

SDL_AppResult SDL_AppIterate(void* appstate)
{
    SDL_memset4(pixelBuffer, 0x000000FF, amountOfPixels);

    for (int i = 0; i < 3000; i++)
    {
        triangle(rand() % 1001 - 500, rand() % 1001 - 500, rand() % 1001 - 500, rand() % 1001 - 500, rand() % 1001 - 500, rand() % 1001 - 500);
    }


    //triangle(sin(a)*200, cos(a) * 200, sin(a + 2.1) * 200, cos(a + 2.1) * 200, sin(a + 4.2) * 200, cos(a + 4.2) * 200);
    a+= 0.005;

    //for (int x = 0; x < WINDOW_WIDTH; x++){for (int y = 0; y < WINDOW_WIDTH; y++){if(pow(y - 500,2) + pow(x - 500,2) < 20000){placePoint(x,y);}}}

    SDL_UpdateTexture(texture, NULL, pixelBuffer,WINDOW_WIDTH*sizeof(Uint32));
    
    SDL_RenderTexture(renderer, texture, NULL, NULL);

    SDL_RenderPresent(renderer);

    return SDL_APP_CONTINUE;
}

void SDL_AppQuit(void* appstate, SDL_AppResult result)
{
    SDL_DestroyTexture(texture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
}

SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event)
{
    if (event->type == SDL_EVENT_QUIT) {
        return SDL_APP_SUCCESS;
    }

    return SDL_APP_CONTINUE;
}
